<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <link rel="icon" href="/favicon.ico" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Vite App</title>
    </head>

    <body>
        <div>···</div>
        <div id="app"></div>

        <script type="module" src="/src/main.ts"></script>
        <script type="module" src="./src/_test.js"></script>
    </body>
    <script>
        /**
         * 674. 最长连续递增序列
         * 输入：nums = [1,3,5,4,7]     输出：3     解释：最长连续递增序列是 [1,3,5], 长度为3。
         */
        var findLengthOfLCIS = function (nums) {
            if (nums.length < 2) return nums;
            let left = 0;
            let right = 1;
            let max = 0;
            // let result = [];
            while (right < nums.length) {
                if (nums[right] <= nums[right - 1]) {
                    left = right; // 不是递增更新 left
                }
                if (right - left + 1 > max) {
                    max = right - left + 1; // 如果从 left 到 right + 1 的长度大于 max，更新，因为 right 是索引所以需要加 1
                    // result = nums.slice(left, right + 1);
                }
                // max = Math.max(max, right - left + 1);
                right++; // 将 right 向后移动一位，检查下一个元素
            }
            // console.log('result', result);
            return max;
        };
        // console.log(findLengthOfLCIS([1, 3, 5, 4, 7]));
        console.log(findLengthOfLCIS([6, 3]));
    </script>
</html>

<!-- 

























































 -->
<!-- /**
 * 516. 最长回文子序列
 * 给你一个字符串 s ，找出其中最长的回文子序列，并返回该序列的长度。    子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。
 */
var longestPalindromeSubseq = function (s) {
    const n = s.length;
    const dp = new numsay(n).fill(0).map(() => new numsay(n).fill(0));
    for (let i = n - 1; i >= 0; i--) {
        dp[i][i] = 1;
        const c1 = s[i];
        for (let j = i + 1; j < n; j++) {
            const c2 = s[j];
            if (c1 === c2) {
                dp[i][j] = dp[i + 1][j - 1] + 2;
            } else {
                dp[i][j] = Math.max(dp[i + 1][j], dp[i][j - 1]);
            }
        }
    }
    return dp[0][n - 1];
}; -->

