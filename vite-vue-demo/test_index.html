<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <link rel="icon" href="/favicon.ico" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Vite App</title>
    </head>

    <body>
        <div>···</div>
        <div id="app"></div>

        <script type="module" src="/src/main.ts"></script>
        <script type="module" src="./src/_test.js"></script>
    </body>
    <script>
        /**
         * 56. 合并区间
         * 以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 。
         * 输入：intervals = [[1,3],[2,6],[8,10],[15,18]]    输出：[[1,6],[8,10],[15,18]]    解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].
         */
        var merge = function (intervals) {
            if (!intervals.length) return;
            const res = [];
            intervals.sort((a, b) => a[0] - b[0]);
            let arr = intervals[0];
            for (let i = 0; i < intervals.length; i++) {
                const cur = intervals[i];
                if (arr[1] >= cur[0]) {
                    arr[1] = Math.max(arr[1], cur[1]);
                } else {
                    res.push(arr);
                    arr = cur;
                }
            }
            res.push(arr);
            return res;
        };
        console.log(
            merge([
                [1, 3],
                [2, 6],
                [8, 10],
                [15, 18],
            ]),
        );
    </script>
</html>
<!-- 

























































 -->
<!-- /**
 * 516. 最长回文子序列
 * 给你一个字符串 s ，找出其中最长的回文子序列，并返回该序列的长度。    子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。
 */
var longestPalindromeSubseq = function (s) {
    const n = s.length;
    const dp = new Array(n).fill(0).map(() => new Array(n).fill(0));
    for (let i = n - 1; i >= 0; i--) {
        dp[i][i] = 1;
        const c1 = s[i];
        for (let j = i + 1; j < n; j++) {
            const c2 = s[j];
            if (c1 === c2) {
                dp[i][j] = dp[i + 1][j - 1] + 2;
            } else {
                dp[i][j] = Math.max(dp[i + 1][j], dp[i][j - 1]);
            }
        }
    }
    return dp[0][n - 1];
}; -->

