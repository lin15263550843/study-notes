<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <link rel="icon" href="/favicon.ico" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Vite App</title>
    </head>

    <body>
        <div>···</div>
        <div id="app"></div>

        <script type="module" src="/src/main.ts"></script>
        <script type="module" src="./src/_test.js"></script>
    </body>
    <script>
        /**
         * 224. 基本计算器
         * 字符串表达式求值，输入一个字符串只包含加减号和括号
         */
        function calcExpression(str) {
            if (typeof str !== 'string') return str;
            str = str.replace(/\s/g, '');
            console.log(str);
            const calcMap = {
                '+': (v1, v2) => Number(v1) + Number(v2),
                '-': (v1, v2) => Number(v1) - Number(v2),
            };
            const calc = () => {
                const ope = opeStack.pop();
                console.log('calc ope ', ope);
                if (!ope) return;
                if (stack.length < 2) return;
                const right = stack.pop();
                const left = stack.pop();
                const res = calcMap[ope](left, right);
                stack.push(res);
            };
            const stack = [];
            const opeStack = [];
            let result = 0;
            for (let i = 0; i < str.length; i++) {
                const cur = str[i];
                console.log('cur-------------------------', i, cur, opeStack, stack);
                if (cur === '+' || cur === '-') {
                    if (!/[0-9)]/.test(str[i - 1]) && /\d/.test(str[i + 1])) {
                        stack.push(cur);
                    } else {
                        calc();
                        opeStack.push(cur);
                    }
                } else if (cur === ')') {
                    calc();
                } else if (cur === '(') {
                    opeStack.push('');
                } else {
                    if (i > 0 && (/\d/.test(str[i - 1]) || !/\d/.test(stack[stack.length - 1]))) {
                        const val = stack.pop() || '';
                        stack.push(val + cur);
                    } else {
                        stack.push(cur);
                    }
                }
                // console.log('cur', i, cur, opeStack, stack);
            }
            if (opeStack > 0 && stack.length < 2) {
                stack.unshift(0);
            }

            console.log('opeStack', opeStack);
            console.log('stack', stack);
            calc();
            return stack[0];
        }
        // var strn1 = '1+1+(4-(3+1))+6';
        // console.log(calcExpression(strn1)); // 6
        // console.log(calcExpression(strn1) === eval(strn1));

        // var strn = '(105  -400 - ( 3 + ( 22 - (-1+ 22) -(10+1) )))';
        // console.log(calcExpression(strn)); // -288
        // console.log(eval(strn)); // -288
        // console.log(calcExpression(strn) === eval(strn));

        // console.log(calcExpression('-2+ 1')); // -1
        console.log(calcExpression('- (3 + (4 + 5))')); // -1

        // function calcExpression(str) {
        //     if (typeof str !== 'string') return str;
        //     str = str.replace(/\s/g, '');
        //     const calcMap = {
        //         '+': (v1, v2) => Number(v1) + Number(v2),
        //         '-': (v1, v2) => Number(v1) - Number(v2),
        //     };
        //     const calc = () => {
        //         console.log('stack', stack, opeStack);
        //         const ope = opeStack.pop();
        //         console.log('ope---- ', ope);
        //         if (ope) {
        //             const right = stack.pop();
        //             const left = stack.pop();
        //             const res = calcMap[ope](left, right);
        //             stack.push(res);
        //         }
        //     };
        //     const stack = [];
        //     const opeStack = [];
        //     let isCalc = true;
        //     for (let i = 0; i < str.length; i++) {
        //         const cur = str[i];
        //         if (cur === '+' || cur === '-') {
        //             opeStack.push(cur);
        //         } else if (cur === '(') {
        //             isCalc = false;
        //         } else if (cur === ')') {
        //             calc();
        //         } else {
        //             stack.push(cur);
        //             if (isCalc) {
        //                 calc();
        //             }
        //             isCalc = true;
        //         }
        //     }
        //     console.log('opeStack', opeStack);
        //     console.log('stack', stack);
        // }
        // var strn1 = '1+1+(4-(3+1))+6';
        // console.log(calcExpression(strn1)); // 6
        // console.log(calcExpression(strn1) === eval(strn1));
    </script>
</html>
<!-- 

























































 -->
<!-- /**
 * 516. 最长回文子序列
 * 给你一个字符串 s ，找出其中最长的回文子序列，并返回该序列的长度。    子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。
 */
var longestPalindromeSubseq = function (s) {
    const n = s.length;
    const dp = new Array(n).fill(0).map(() => new Array(n).fill(0));
    for (let i = n - 1; i >= 0; i--) {
        dp[i][i] = 1;
        const c1 = s[i];
        for (let j = i + 1; j < n; j++) {
            const c2 = s[j];
            if (c1 === c2) {
                dp[i][j] = dp[i + 1][j - 1] + 2;
            } else {
                dp[i][j] = Math.max(dp[i + 1][j], dp[i][j - 1]);
            }
        }
    }
    return dp[0][n - 1];
}; -->

